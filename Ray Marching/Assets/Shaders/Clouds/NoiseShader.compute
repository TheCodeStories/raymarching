#pragma kernel CSMain

RWTexture2D<float4> Result;

uniform float _Resolution;
uniform float _Scale;
uniform float _Boost;
uniform int _Octaves;
uniform float _TileSize;

// uint hash2D(int2 p) {
//     // A quick integer hash: based on SquirrelNoise
//     uint h = (uint)(p.x * 374761393u + p.y * 668265263u); // large primes
//     h = (h ^ (h >> 13u)) * 1274126177u;
//     return h ^ (h >> 16u);
// }

// float2 perlinHash(float2 p)
// {
//     int2 ip = (int2)p;

//     static const float2 gradients[8] = {
//         float2(1,0), float2(-1,0), float2(0,1), float2(0,-1),
//         normalize(float2(1,1)), normalize(float2(-1,1)),
//         normalize(float2(1,-1)), normalize(float2(-1,-1))
//     };

//     uint idx = hash2D(ip) % 8;
//     return gradients[idx];
// }

uint hash2D(int2 p) {
    uint h = (uint)(p.x * 374761393u + p.y * 668265263u);
    h = (h ^ (h >> 13u)) * 1274126177u;
    return h ^ (h >> 16u);
}

float2 perlinHash(float2 p)
{
    int2 ip = (int2)p;
    uint h = hash2D(ip);

    float rand = frac(h * 0.00000011920928955078125); 

    float angle = rand * 6.2831853; 

    return float2(cos(angle), sin(angle));
}

float2 fade(float2 t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float perlinNoise(float2 uv){
    float2 pa = floor(uv);
    float2 pb = pa + float2(1, 0);
    float2 pc = pa + float2(0, 1);
    float2 pd = pa + float2(1, 1);
    
    float2 a = perlinHash(pa); 
    float2 b = perlinHash(pb); 
    float2 c = perlinHash(pc); 
    float2 d = perlinHash(pd);
    
    float2 f = frac(uv);

    float2 va = f - float2(0, 0); 
    float2 vb = f - float2(1, 0); 
    float2 vc = f - float2(0, 1); 
    float2 vd = f - float2(1, 1); 

    float da = dot(a, va);
    float db = dot(b, vb);
    float dc = dot(c, vc);
    float dd = dot(d, vd);

    float2 w = fade(f);

    float x1 = lerp(da, db, w.x);
    float x2 = lerp(dc, dd, w.x);
    float result = lerp(x1, x2, w.y);

    return result;
}

float fbm(float2 uv, int octaves, float lacunarity, float gain)
{
    float sum = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float totalAmplitude = 0.0;

    for (int i = 0; i < octaves; ++i)
    {

        sum += perlinNoise(uv * frequency) * amplitude;
        totalAmplitude += amplitude;

        frequency *= lacunarity; 
        amplitude *= gain;       
    }

    return sum / totalAmplitude;
}
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2(id.xy) + 0.5) * _Scale;

    float value = fbm(uv, _Octaves, 2.0, 0.5);
    value = value * 0.5 + 0.5;
    value *= _Boost;

    Result[id.xy] = float4(value, value, value, 1.0);
}
